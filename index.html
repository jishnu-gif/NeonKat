
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NeonKat</title>
  <script src="jsmediatags.min.js"></script>
  <script src="hls.js@latest"></script>
  <style>
    :root {
      --primary-color: #a88cff;
      --primary-dark: #7a5fff;
    }

    
    body {
      margin: 0;
      padding: 0;                  
      background: transparent;
      color: #fff;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;     
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      outline: none !important;
      border-radius: 10px;
    }

#visualizerControls,
#hamburgerBtn,
#playlist li,
#chooseFolder,
#addStreamBtn,
#sortBtn,
#miniPlayerBtn,
#notifyToggleBtn,
#visualizerToggleBtn,
#rainbowToggleBtn,
button,

a {
  
    outline: none !important;
}


.control-btn img,
#topControls img,
.icon {
  -webkit-app-region: no-drag !important;
  pointer-events: auto !important;
    outline: none !important;
}


    .control-btn img,
    .icon,
    #topControls img,
    #bellIcon,
    #visualizerIcon,
    #rainbowIcon,
    #miniPlayerBtn img {
      filter: brightness(0) invert(1) !important;
    }
      #container {
        width: 441px;            
        height: 743px;               
        max-width: none;
        max-height: none;
        background: #111;
        padding: 15px;
        border-radius: 10px;
        border: 6px solid var(--primary-color); 
        box-sizing: border-box;      
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-top: 0;             
      }
    h1 {
      font-size: 24px;
      text-align: center;
      margin: 0 0 10px;
      color: #ffffff;
      margin-left: 145px;
    }
    #chooseFolder {
      background: #212121;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      width: 100%;
      margin-bottom: 10px;
      font-size: 14px;
      -webkit-app-region: no-drag;
    }
    #chooseFolder:hover {
      background: var(--primary-color);
    }
    #savePlaylistBtn, #loadPlaylistBtn, #sortBtn {
      background: #212121;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      width: 100%;
      margin-bottom: 10px;
      font-size: 14px;
      -webkit-app-region: no-drag;
    }
    #savePlaylistBtn:hover, #loadPlaylistBtn:hover, #sortBtn:hover {
      background: var(--primary-color);
    }
    #playlist,
    #playlist li {
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
    }
    #selectedFolderName {
      font-size: 14px;
      color: var(--primary-color);
      text-align: center;
      margin-bottom: 10px;
      -webkit-app-region: no-drag;
    }
    #sortMenu {
      position: absolute;
      background: #222;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      z-index: 10;
      display: none;
      width: 150px;
      -webkit-app-region: no-drag;
    }
    #sortMenu button {
      background: #212121;
      color: white;
      border: none;
      padding: 10px;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
      -webkit-app-region: no-drag;
    }
    #sortMenu button:hover {
      background: var(--primary-color);
    }
  
  #playlist {
  list-style: none;
  padding: 0;
  margin: 0 0 15px;
  flex: 1;                    
  min-height: 150px;
  max-height: 270px;         
  overflow-y: auto;
  background: #222;
  border-radius: 5px;
  -webkit-app-region: no-drag;
}
    #playlist li {
      padding: 10px;
      cursor: pointer;
      border-bottom: 1px solid #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 12px;
    }
    #playlist li:last-child {
      border-bottom: none;
    }
    #playlist li:hover {
      background: var(--primary-color);
    }
    #playlist li.active {
      background: #0c0c0c;
      color: #fff;
    }
    #playlist::-webkit-scrollbar {
      width: 8px;
    }
    #playlist::-webkit-scrollbar-track {
      background: #111;
      border-radius: 5px;
    }
    #playlist::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, #212121, var(--primary-color));
      border-radius: 5px;
    }
    #playlist::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(to bottom, var(--primary-color), #b19cd9);
    }
    input[type="range"] {
      appearance: none;
      width: 100%;
      height: 5px;
      background: #444;
      border-radius: 5px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      position: relative;
      z-index: 2;
    }
    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      gap: 10px;
      flex-wrap: wrap;
      -webkit-app-region: no-drag;
    }
    .control-btn.repeat-enabled {
      background: var(--primary-color) !important;
      color: #fff;
      -webkit-app-region: no-drag;
    }
    .control-btn.enabled {
      background-color: var(--primary-color) !important;
      color: white !important;
    }
    .control-btn {
      background: #212121;
      color: white;
      border: none;
      padding: 10px 0;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      flex: 1 1 0;
      text-align: center;
      white-space: nowrap;
      height: 38px;
      line-height: 1.2;
      -webkit-app-region: no-drag;
    }
    .control-btn:hover {
      background: var(--primary-color) !important;
    }

    * {
  transition: none !important;
}
    #volume {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 100px;
      height: 5px;
      background: #444;
      outline: none;
      border-radius: 5px;
      margin-left: 10px;
      -webkit-app-region: no-drag;
    }
    #volume::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    #volume::-moz-range-thumb {
      -moz-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    #visualizer {
      width: 100%;
      height: 120px;
      background: #111111;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 5px;
      overflow: hidden;
      box-shadow: inset 0 0 250px #000000bf;
      margin-bottom: 10px;
      position: relative;
      background-size: 100% 100%;
      -webkit-app-region: no-drag;
    }
    #progressContainer {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
      font-size: 12px;
      color: #ffffff;
      -webkit-app-region: no-drag;
    }
    #progressBar {
      flex: 1;
      height: 6px;
      background: #444;
      border-radius: 3px;
      -webkit-appearance: none;
      appearance: none;
      -webkit-app-region: no-drag;
    }
    #progressBar::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
    }
    #progressBar::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
    }
    footer {
      text-align: right;
      font-size: 9px;
      font-weight: bold;
      color: #ffffff;  
      pointer-events: none;
      height: 13px !important;
    }


    #streamUrlInput:focus,
      #streamNameInput:focus,
      #ytUrlInput {
        outline: none !important;
    }

#playlist li.selected {
  background: var(--primary-color) !important;
  color: #000;
  font-weight: bold;
}

#playlist li.selected.active {
  background: var(--primary-color) !important;
  font-weight: bold;
}

    title {
    text-align: center;
      font-size: 12px;
      color: #ffffff;
        font-weight: bold;

    }
    .icon {
      width: 20px;
      height: 20px;
      object-fit: contain;
      filter: brightness(0) invert(1);
    }
    #topControls {
      display: flex;
      align-items: center;
      gap: 0px;
      margin-bottom: 1px;
      flex-wrap: nowrap;
      -webkit-app-region: drag;
          width: 173px;
    }
    #visualizerControls {
      display: flex;
      align-items: center;
      gap: 5px;
      -webkit-app-region: no-drag;
    }
    #visualizerColor {
      height: 20px;
      width: 20px;
      padding: 0;
      border: none;
      background: #111111;
      cursor: pointer;
    }

    #visualizerCanvas{
     background-size: revert-layer !important;

    }

    #contextMenu button:hover {
      background: var(--primary-color);
    }

    #contextMenu button:active {
      background: var(--primary-color);
    }
    body.mini-mode #container {
      width: 260px !important;
      height: 290px !important;    
      padding: 10px !important;    
      box-sizing: border-box !important;
    }

    body.mini-mode h1,
    body.mini-mode #playlist,
    body.mini-mode #playlistControls,
    body.mini-mode #sortBtn,
    body.mini-mode #sortMenu,
    body.mini-mode #chooseFolder,
    body.mini-mode #addStreamBtn,
    body.mini-mode #hamburgerMenu,
    body.mini-mode #hamburgerBtn
    {
      display: none !important;
    }

    body.mini-mode .controls {
      margin-top: 5px;
    }

    body.mini-mode #visualizer {
      height: 80px !important;
      background-position: center !important;
      image-rendering: pixelated;
    }

    #hamburgerMenu button:hover {
  background: var(--primary-color) !important;
  color: black !important;
}

#hamburgerBtn svg {
  filter: brightness(0) invert(1);
}

#hamburgerBtn:hover svg {
  stroke: var(--primary-color);
}




  </style>
</head>
<body>
  <div id="titlebar" style="-webkit-app-region: drag; height: 20px; position: absolute; top: 0; left: 0; right: 0; z-index: 1;">
  </div>
  <div id="rainbow-helper"></div>
  <div id="container">
  <div id="topControls" style="width: 100%; justify-content: space-between;">
  <div style="display: flex; align-items: center; gap: 0px;">
    <button id="notifyToggleBtn" style="background: none; border: none; cursor: pointer;" title="Notifications">
      <img src="build/bell.svg" id="bellIcon" height="17" />
    </button>
    <div id="visualizerControls">
      <button id="visualizerToggleBtn" style="background: none; border: none; cursor: pointer;" title="Audio Visualizer">
        <img src="build/visualizer.svg" id="visualizerIcon" height="20" />
      </button>
      <input type="color" id="visualizerColor" value="#a88cff" title="Select Theme Color" />
      <button id="rainbowToggleBtn" style="background: none; border: none; cursor: pointer;" title="Neon Mode">
        <img id="rainbowIcon" src="build/flashoff.svg" height="27" />
      </button>
    </div>
    <button id="miniPlayerBtn" style="background: none; border: none; cursor: pointer; margin-left: 10px;" title="Mini Player">
      <img src="build/miniplayer.svg" height="20" />
    </button>

    
  </div>



  <button id="hamburgerBtn" style="background: none; border: none; cursor: pointer; padding: 8px; -webkit-app-region: no-drag;" title="Menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round">
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </button>
</div>


<div id="hamburgerMenu" style="position: absolute; top: 70px; right: 15px; background: #222; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.6); border: 2px solid var(--primary-color); display: none; z-index: 9999; min-width: 200px; -webkit-app-region: no-drag;">
  <button id="downloadYoutubeBtn" style="width: 100%; padding: 14px 20px; background: none; border: none; color: white; text-align: left; font-size: 14px; cursor: pointer; border-bottom: 1px solid #333;">
    Download With Yt-Dlp
  </button>
  <button id="aboutBtn" style="width: 100%; padding: 14px 20px; background: none; border: none; color: white; text-align: left; font-size: 14px; cursor: pointer;">
    About NeonKat
  </button>
</div>
    <h1 style="display: flex; align-items: center; gap: 8px; ">
      NeonKat
      <img src="build/kat.png" style="height: 54px;" />
    </h1>
 <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
  <button id="chooseFolder" style="flex: 1;">Choose Folder</button>
  <button id="addStreamBtn" class="control-btn" style="flex: 1;">Add Stream</button>
</div>

    <div id="streamModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; border-radius: 10px; background: rgba(0,0,0,0.8); border-radius: 10px; justify-content: center; align-items: center; z-index: 9999;">
  <div style="background: #111111; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px; color: white;  border: 3px solid var(--primary-color);
    border-radius: 10px;-webkit-app-region: no-drag;">
    <h3 style="margin-top: 0; color: var(--primary-color);">Add Radio Stream</h3>
    <label>Stream URL (.mp3, .aac, .pls, .m3u etc.):</label>
    <input type="text" id="streamUrlInput" style="width: 100%; padding: 10px; margin: 10px 0; background: #111111; border: none; border-radius: 5px; color: white;" placeholder="https://example.com/stream.mp3" />
    
    <label>Station Name (optional):</label>
    <input type="text" id="streamNameInput" style="width: 100%; padding: 10px; margin: 10px 0; background: #111111; border: none; border-radius: 5px; color: white;" placeholder="My Favorite Station" />
    
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
      <button id="cancelStreamBtn" style="background: #444; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Cancel</button>
      <button id="addStreamConfirmBtn" style="background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Add</button>
    </div>
  </div>
</div>
    <div style="position: relative;">
      <button id="sortBtn">Sort Playlist</button>
      <div id="sortMenu">
        <button id="sortNameAsc">Name (A-Z)</button>
        <button id="sortNameDesc">Name (Z-A)</button>
        <button id="sortDateDesc">Date (Newest)</button>
        <button id="sortDateAsc">Date (Oldest)</button>
      </div>
    </div>

    <div id="contextMenu" style="position: fixed; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 6px 0; display: none; z-index: 9999; box-shadow: 0 4px 12px rgba(0,0,0,0.6);">
  <button id="removeTrackBtn" class="control-btn" style="width: 100%; padding: 8px 20px; background: none; border: none; color: #fff; text-align: left; cursor: pointer; font-size: 13px; height: auto; line-height: 1;">
  Remove from Playlist
</button>
</div>
    <ul id="playlist"></ul>
    <div class="controls" style="display: flex; gap: 10px; margin-bottom: 10px;">
      <button id="playPauseBtn" class="control-btn">
        <img id="playPauseIcon" src="build/play.svg" alt="Play/Pause" class="icon" />
      </button>
      <button id="repeatBtn" class="control-btn">
        <img src="build/repeat.svg" alt="Repeat" class="icon" />
      </button>
      <button id="shuffleBtn" class="control-btn">
        <img src="build/shuffle.svg" alt="Shuffle" class="icon" />
      </button>
    </div>
    <div id="playlistControls" style="display: flex; gap: 10px; margin-bottom: 10px;">
      <button id="savePlaylistBtn" class="control-btn">Save</button>
      <button id="loadPlaylistBtn" class="control-btn">Load</button>
      <button id="clearPlaylistBtn" class="control-btn">Clear</button>
    </div>
    <div class="volume-control" style="display: flex; align-items: center; gap: 5px;">
         <label for="volume">
        <img src="build/volume.svg" alt="Volume" width="20" height="20" > 
        <input type="range" id="volume" min="0" max="1" step="0.01" value="1" />
        <span id="volumePercent">100%</span>
      <div id="selectedFolderName"></div>
    </div>
    <div id="progressContainer">
      <span id="currentTime">0:00</span>
      <input type="range" id="progressBar" value="0" min="0" step="0.1" />
      <span id="duration">0:00</span>
    </div>
    <canvas id="visualizer"></canvas>
    <footer>
  <img src="build/kat.png" alt=':)' style="    width: 15px;
    height: 15px;
    margin-right: 8px;
    vertical-align: middle;
    -webkit-app-region: drag;
    transform: scale(2) !important; -webkit-app-region: drag;">
  NeonKat
</footer>
  </div>
  <audio id="audio"></audio>
  <style>
label img {
  filter: brightness(0) invert(1);
  top: 7px;
  position: relative;
}

</style>
<script>
  const filePickerBtn = document.getElementById('chooseFolder');
  const savePlaylistBtn = document.getElementById('savePlaylistBtn');
  const loadPlaylistBtn = document.getElementById('loadPlaylistBtn');
  const selectedFolderName = document.getElementById('selectedFolderName');
  const playlistElem = document.getElementById('playlist');
  const audio = document.getElementById('audio');
  const visualizerCanvas = document.getElementById('visualizer');
  const ctx = visualizerCanvas.getContext('2d');
  const volumeSlider = document.getElementById('volume');
  const progressBar = document.getElementById('progressBar');
  const currentTimeElem = document.getElementById('currentTime');
  const durationElem = document.getElementById('duration');
  const sortBtn = document.getElementById('sortBtn');
  const sortMenu = document.getElementById('sortMenu');
  
  let audioFiles = [];
  let rainbowIntervalId = null;
  let currentIndex = 0;

let flashIntensity = 0; 
  let isSeeking = false;
  let repeatTrack = false;
  let shuffleTrack = false;
  let notifyEnabled = localStorage.getItem('notifyEnabled') === 'true';
  let visualizerToggle = localStorage.getItem('visualizerToggle') === 'true';
  let animationFrameId = null;
  let themeColor = localStorage.getItem('themeColor') || '#a88cff';
  let isRainbowActive = localStorage.getItem('isRainbowActive') === 'true';
  const rainbowIcon = document.getElementById('rainbowIcon');
  rainbowIcon.src = isRainbowActive ? 'build/flash.svg' : 'build/flashoff.svg';
  const rainbowToggleBtn = document.getElementById('rainbowToggleBtn');
  let rainbowFrameId = null;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 128;
  const source = audioCtx.createMediaElementSource(audio);
  source.connect(analyser);
  const lowpass = audioCtx.createBiquadFilter();
lowpass.type = 'lowpass';
lowpass.frequency.value = 150;  
lowpass.Q.value = 1;           

source.connect(lowpass);
lowpass.connect(analyser);
analyser.connect(audioCtx.destination); 
  analyser.connect(audioCtx.destination);
  const radioIconImg = new Image();
  radioIconImg.src = 'build/radio.svg';


  const repeatBtn = document.getElementById('repeatBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const visualizerColorPicker = document.getElementById('visualizerColor');
  const miniplayerToggleBtn = document.getElementById('miniplayerToggleBtn');
    const miniBtn = document.getElementById('miniPlayerBtn');
    let isMini = false;




const hamburgerBtn = document.getElementById('hamburgerBtn');
const hamburgerMenu = document.getElementById('hamburgerMenu');
const downloadYoutubeBtn = document.getElementById('downloadYoutubeBtn');

let menuOpen = false;

hamburgerBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  menuOpen = !menuOpen;
  hamburgerMenu.style.display = menuOpen ? 'block' : 'none';
});


document.addEventListener('click', () => {
  if (menuOpen) {
    menuOpen = false;
    hamburgerMenu.style.display = 'none';
  }
});


hamburgerMenu.addEventListener('click', (e) => {
  e.stopPropagation();
});

downloadYoutubeBtn.addEventListener('click', () => {
  hamburgerMenu.style.display = 'none';
  menuOpen = false;

  if (document.getElementById('ytModal')) {
    document.getElementById('ytModal').style.display = 'flex';
    return;
  }




  const modalHTML = `
<div id="ytModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); border-radius: 10px; display: flex; justify-content: center; align-items: center; z-index: 99999;">
  <div style="background: #111; padding: 25px; border-radius: 12px; width: 90%; max-width: 420px; border: 3px solid var(--primary-color);">
    <h3 style="margin-top: 0; color: var(--primary-color); text-align: center;">Download With Yt-Dlp</h3>
    
    <!-- Permanent warning right under the title -->
    <div style="background: #330000; border: 1px solid #ff3333; padding: 12px; border-radius: 8px; margin: 15px 0 20px 0; font-size: 13px; color: #ffaaaa; text-align: center;">
      <strong>⚠️ HEADS UP ⚠️</strong><br><br>
      Downloading large playlists (50+ videos) at once can get your IP temporarily rate-limited by YouTube for up to 24 hours.<br>
      Stick to single videos or smaller batches to avoid getting fucked by their servers.
    </div>
    
    <input type="text" id="ytUrlInput" placeholder="Paste YouTube / Soundcloud URL here..." style="width: 100%; padding: 12px; background: #222; border: none; border-radius: 6px; color: white; margin-bottom: 10px; font-size: 14px;" />
    
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
      <button id="chooseDlFolderBtn" style="padding: 10px 15px; background: #212121; border: none; border-radius: 6px; color: white; cursor: pointer; flex: 1;">Choose Folder</button>
      <span id="selectedDlFolder" style="color: var(--primary-color); font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 2;">No folder selected</span>
    </div>
    
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
      <button id="cancelYtBtn" style="padding: 10px 20px; background: #444; border: none; border-radius: 6px; color: white; cursor: pointer;">Cancel</button>
      <button id="downloadYtConfirmBtn" style="padding: 10px 20px; background: var(--primary-color); border: none; border-radius: 6px; color: black; cursor: pointer; font-weight: bold;">Download</button>
    </div>
  </div>
</div>`;





  document.body.insertAdjacentHTML('beforeend', modalHTML);

  const ytModal = document.getElementById('ytModal');
  const ytUrlInput = document.getElementById('ytUrlInput');
  const cancelBtn = document.getElementById('cancelYtBtn');
  const confirmBtn = document.getElementById('downloadYtConfirmBtn');
  const chooseFolderBtn = document.getElementById('chooseDlFolderBtn');
  const selectedFolderSpan = document.getElementById('selectedDlFolder');

  let downloadFolder = null; 
  ytUrlInput.focus();
  chooseFolderBtn.addEventListener('click', async () => {
    const result = await window.electronAPI.pickDownloadFolder();
    if (result.success) {
      downloadFolder = result.folderPath;
      selectedFolderSpan.textContent = downloadFolder;
    } else {
      selectedFolderSpan.textContent = 'Canceled';
    }
  });

  cancelBtn.addEventListener('click', () => ytModal.remove());
  ytModal.addEventListener('click', (e) => { if (e.target === ytModal) ytModal.remove(); });

  confirmBtn.addEventListener('click', async () => {
    const url = ytUrlInput.value.trim();
    if (!url) {
      alert('Paste a fucking URL first!');
  return;
}


if (!url.includes('youtube.com') && !url.includes('youtu.be') && !url.includes('soundcloud.com')) {
  alert('Stick to YouTube or SoundCloud links for now, Should i add more? let me know :)');
}

    if (!downloadFolder) {
      alert('Pick a folder first');
      return;
    }

    confirmBtn.textContent = 'Downloading...';
    confirmBtn.disabled = true;
    const result = await window.electronAPI.downloadYoutube({ url, downloadFolder });

    if (result.success) {
  renderPlaylist();
  if (Notification.permission === 'granted') {
    window.electronAPI.notify('Download Complete :)');
  }
  else{alert(`Download Fucked Up :(`)}
} else {
  if (Notification.permission === 'granted') {
    window.electronAPI.notify('Download Fucked Up :(');
  }

  else{alert(`Download Fucked Up :(`)}
}

   confirmBtn.textContent = 'Download';
    confirmBtn.disabled = false;
  });
});



    const aboutBtn = document.getElementById('aboutBtn');

aboutBtn.addEventListener('click', () => {
  hamburgerMenu.style.display = 'none';
  menuOpen = false;

  if (document.getElementById('aboutModal')) {
    document.getElementById('aboutModal').style.display = 'flex';
    return;
  }

  const modalHTML = `
  <div id="aboutModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); border-radius: 10px; display: flex; justify-content: center; align-items: center; z-index: 99999;">
    <div style="background: #111; padding: 30px; border-radius: 12px; width: 90%; max-width: 400px; border: 3px solid var(--primary-color); text-align: center; color: white;">
      <h3 style="margin-top: 0; color: var(--primary-color);">About NeonKat</h3>
      
      <p style="font-size: 16px; margin: 15px 0;">Made With ❤️ By <strong>PaleCache</strong></p>
      
      <p style="font-size: 14px; margin-bottom: 20px;">A music player with YouTube ripping, streams, and neon vibes. Check out the source and star it if you love it!</p>
      
      <button id="openGitHubBtn" style="padding: 12px 25px; background: var(--primary-color); border: none; border-radius: 6px; color: black; cursor: pointer; font-weight: bold; margin-bottom: 15px;">Source Code</button>
      
      <button id="closeAboutBtn" style="padding: 10px 20px; background: #444; border: none; border-radius: 6px; color: white; cursor: pointer;">Close</button>
    </div>
  </div>`;

  document.body.insertAdjacentHTML('beforeend', modalHTML);

  const aboutModal = document.getElementById('aboutModal');
  const closeBtn = document.getElementById('closeAboutBtn');
  const gitHubBtn = document.getElementById('openGitHubBtn');
  const gitHubUrl = 'https://github.com/PaleCache/NeonKat';

  gitHubBtn.addEventListener('click', async () => {
    await window.electronAPI.openExternal(gitHubUrl);
  });

  closeBtn.addEventListener('click', () => aboutModal.remove());
  aboutModal.addEventListener('click', (e) => { if (e.target === aboutModal) aboutModal.remove(); });
});

    miniBtn.addEventListener('click', () => {
      isMini = !isMini;
      document.body.classList.toggle('mini-mode', isMini);
      window.electronAPI.setMiniMode(isMini);
      setTimeout(visualize, 100);
    });
  function updateSliderBackground(slider) {
    const value = (slider.value - slider.min) / (slider.max - slider.min) * 100;
    slider.style.background = `linear-gradient(to right, var(--primary-color) 0%, var(--primary-color) ${value}%, #444 ${value}%, #444 100%)`;
  }

  function updateThemeColor(color, isRainbow = isRainbowActive) {
    themeColor = color;
    isRainbowActive = isRainbow;
    localStorage.setItem('themeColor', themeColor);
    localStorage.setItem('isRainbowActive', isRainbowActive);

    window.electronAPI.updateTheme({ color, isRainbow });

    if (isRainbowActive) {
    } else {
      document.documentElement.style.setProperty('--primary-color', themeColor);
      document.documentElement.style.setProperty('--primary-dark', adjustColor(themeColor, -20));
    }

    updateSliderBackground(volumeSlider);
    updateSliderBackground(progressBar);
  }

  visualizerColorPicker.value = themeColor;
  updateThemeColor(themeColor, isRainbowActive);

  visualizerColorPicker.addEventListener('input', (e) => {
    updateThemeColor(e.target.value, false);
  });

rainbowToggleBtn.addEventListener('click', () => {
  isRainbowActive = !isRainbowActive;
  rainbowIcon.src = isRainbowActive ? 'build/flash.svg' : 'build/flashoff.svg';
  localStorage.setItem('isRainbowActive', isRainbowActive);
  if (isRainbowActive) {
    updateThemeColor(themeColor, true);
  } else {
    updateThemeColor(themeColor, false);
  }
});


const addStreamBtn = document.getElementById('addStreamBtn');
const streamModal = document.getElementById('streamModal');
const streamUrlInput = document.getElementById('streamUrlInput');
const streamNameInput = document.getElementById('streamNameInput');
const cancelStreamBtn = document.getElementById('cancelStreamBtn');
const addStreamConfirmBtn = document.getElementById('addStreamConfirmBtn');

addStreamBtn.addEventListener('click', () => {
  streamUrlInput.value = '';
  streamNameInput.value = '';
  streamModal.style.display = 'flex';
  streamUrlInput.focus();
});

cancelStreamBtn.addEventListener('click', () => {
  streamModal.style.display = 'none';
});

addStreamConfirmBtn.addEventListener('click', () => {
  let url = streamUrlInput.value.trim();
  if (!url) {
    alert('Fuck, enter a URL first!');
    return;
  }

  let name = streamNameInput.value.trim() || new URL(url).hostname;
  if (url.toLowerCase().endsWith('.pls') || url.toLowerCase().endsWith('.m3u')) {
    fetch(url)
      .then(r => r.text())
      .then(text => {
        const lines = text.split('\n');
        for (let line of lines) {
          line = line.trim();
          if (line.startsWith('File1=') || line.toLowerCase().includes('http')) {
            const match = line.match(/(https?:\/\/[^\s]+)/i);
            if (match) {
              addStreamToPlaylist(match[1], name);
              streamModal.style.display = 'none';
              return;
            }
          }
        }
        alert('No valid stream found in that playlist file');
      })
      .catch(err => {
        console.error(err);
        alert('Couldn\'t fetch the playlist file. Try a direct stream URL.');
      });
  } else {
    addStreamToPlaylist(url, name);
    streamModal.style.display = 'none';
  }
});


streamModal.addEventListener('click', (e) => {
  if (e.target === streamModal) {
    streamModal.style.display = 'none';
  }
});



function addStreamToPlaylist(url, customName = null) {
  const name = customName || new URL(url).hostname;

  const streamEntry = {
    url: url,
    name: name,
    isStream: true
  };

  audioFiles.push(streamEntry);
  renderPlaylist();
  updateStoredPlaylist();
  currentIndex = audioFiles.length - 1;
  playTrack(currentIndex);
}



let savedSortedOrder = []; 
let isShuffled = false;
shuffleBtn.classList.toggle('enabled', isShuffled);

shuffleBtn.addEventListener('click', () => {
  
  isShuffled = !isShuffled;
  shuffleBtn.classList.toggle('enabled', isShuffled);
  if (isShuffled && Notification.permission === 'granted') {
    window.electronAPI.notify('Shuffle Enabled');
  }

  if (!isShuffled && Notification.permission === 'granted') {
    window.electronAPI.notify('Shuffle Disabled');
  }

  if (isShuffled) {
    savedSortedOrder = [...audioFiles];
    const currentTrack = audioFiles[currentIndex];
    let remaining = audioFiles.filter((_, i) => i !== currentIndex);
    shuffleArray(remaining);
    audioFiles = [currentTrack, ...remaining];
    currentIndex = 0;

  } else {
    audioFiles = [...savedSortedOrder];
    const currentTrack = audioFiles[currentIndex];
    const restoredIndex = audioFiles.findIndex(item => deepEqual(item, currentTrack));
    currentIndex = restoredIndex !== -1 ? restoredIndex : 0;
  }

  renderPlaylist();
  updateSelectionVisuals();
  scrollToCurrentTrack();
});


function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}


function deepEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a === 'string') return a === b;
  if (a.isStream && b.isStream) {
    return a.url === b.url && a.name === b.name;
  }
  return false;
}

  repeatBtn.addEventListener('click', () => {
    

  
    repeatTrack = !repeatTrack;
    repeatBtn.classList.toggle('enabled', repeatTrack);

    if (repeatTrack && Notification.permission === 'granted') {
    window.electronAPI.notify('Repeat Enabled');
  }

  if (!repeatTrack && Notification.permission === 'granted') {
    window.electronAPI.notify('Repeat Disabled');
  }
  });

  sortBtn.addEventListener('click', () => {
    if (sortMenu.style.display === 'block') {
      sortMenu.style.display = 'none';
    } else {
      sortMenu.style.display = 'block';
    }
  });

  const contextMenu = document.getElementById('contextMenu');
const removeTrackBtn = document.getElementById('removeTrackBtn');

removeTrackBtn.addEventListener('click', () => {
  if (selectedIndices.size === 0) return;

  const indicesToRemove = Array.from(selectedIndices).sort((a, b) => b - a);

  let shouldStopPlayback = false;
  indicesToRemove.forEach(idx => {
    if (idx === currentIndex) shouldStopPlayback = true;
    audioFiles.splice(idx, 1);
  });

  if (shouldStopPlayback || audioFiles.length === 0) {
    audio.pause();
    audio.src = '';
    currentIndex = 0;
    window.electronAPI.updateTrack({ songName: 'No Track', artUrl: null, isPlaying: false });
  } else if (currentIndex >= audioFiles.length) {
    currentIndex = audioFiles.length - 1;
  }

  selectedIndices.clear();
  lastSelectedIndex = null;
  renderPlaylist();
  if (audioFiles.length > 0) playTrack(currentIndex);

  contextMenu.style.display = 'none';
  contextMenuOpen = false;
});

playlistElem.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const li = e.target.closest('li');
  if (!li) return;

  const index = Array.from(playlistElem.children).indexOf(li);
  showContextMenu(e.clientX, e.clientY, index);
});

let contextMenuOpen = false;

function showContextMenu(x, y, index) {
  contextMenuOpen = true;
  contextMenu.style.left = `${x}px`;
  contextMenu.style.top = `${y}px`;
  contextMenu.style.display = 'block';
}


document.addEventListener('click', (e) => {
  if (contextMenuOpen && !contextMenu.contains(e.target)) {
    contextMenu.style.display = 'none';
    contextMenuOpen = false;
  }
});

  document.getElementById('sortNameAsc').addEventListener('click', () => {
    sortPlaylist('name', true);
    sortMenu.style.display = 'none';
  });

  document.getElementById('sortNameDesc').addEventListener('click', () => {
    sortPlaylist('name', false);
    sortMenu.style.display = 'none';
  });

  document.getElementById('sortDateAsc').addEventListener('click', () => {
    sortPlaylist('date', true);
    sortMenu.style.display = 'none';
  });

  document.getElementById('sortDateDesc').addEventListener('click', () => {
    sortPlaylist('date', false);
    sortMenu.style.display = 'none';
  });

  document.addEventListener('click', (e) => {
    if (!sortBtn.contains(e.target) && !sortMenu.contains(e.target)) {
      sortMenu.style.display = 'none';
    }
  });

  async function sortPlaylist(criteria, ascending) {
    if (audioFiles.length === 0) return 0;

    audioFiles = [...new Set(audioFiles)];
    let sortedFiles = [...audioFiles];

    const currentFile = audioFiles[currentIndex];

    if (criteria === 'name') {
      sortedFiles.sort((a, b) => {
        const nameA = a.split(/[\\/]/).pop().toLowerCase();
        const nameB = b.split(/[\\/]/).pop().toLowerCase();
        return ascending ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
      });
    } else if (criteria === 'date') {
      try {
        const filesWithDates = await Promise.all(
          audioFiles.map(async (file) => {
            try {
              const stats = await window.electronAPI.getFileStats(file);
              const mtimeMs = stats?.mtimeMs ?? 0;
              return { file, date: mtimeMs, name: file.split(/[\\/]/).pop().toLowerCase() };
            } catch {
              return { file, date: 0, name: file.split(/[\\/]/).pop().toLowerCase() };
            }
          })
        );
        filesWithDates.sort((a, b) => {
          const diff = ascending ? a.date - b.date : b.date - a.date;
          if (Math.abs(a.date - b.date) < 1000) {
            return ascending ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name);
          }
          return diff;
        });
        sortedFiles = filesWithDates.map(item => item.file);
      } catch (err) {
        console.error('Sort failed:', err);
        return 0;
      }
    }

    audioFiles = sortedFiles;
    currentIndex = audioFiles.indexOf(currentFile);
    if (currentIndex === -1) currentIndex = 0;

    renderPlaylist();

    localStorage.setItem('sortCriteria', criteria);
    localStorage.setItem('sortOrder', ascending ? 'asc' : 'desc');
    localStorage.setItem('sortedPlaylist', JSON.stringify(audioFiles));

    return currentIndex;
  }

 
  const sortOptions = sortMenu.querySelectorAll('button');
  sortOptions.forEach(btn => {
    btn.addEventListener('click', () => {
      sortOptions.forEach(b => b.textContent = b.textContent.replace(' ✓', ''));
      btn.textContent += ' ✓';
      selectedSort = btn.id;
      sortMenu.style.display = 'none';
    });
  });

  function updateSortCheckmark(selectedId) {
    sortOptions.forEach(btn => {
      if (btn.id === selectedId) {
        if (!btn.textContent.includes(' ✓')) {
          btn.textContent += ' ✓';
        }
      } else {
        btn.textContent = btn.textContent.replace(' ✓', '');
      }
    });
  }

  playlistElem.addEventListener('dragover', (event) => {
    event.preventDefault();
    playlistElem.style.border = '2px dashed #212121';
  });

  window.addEventListener('resize', () => {
  setTimeout(visualize, 50);
});

  playlistElem.addEventListener('dragleave', (event) => {
    event.preventDefault();
    playlistElem.style.border = '';
  });

  playlistElem.addEventListener('drop', async (event) => {
    event.preventDefault();
    playlistElem.style.border = '';
    const files = Array.from(event.dataTransfer.files);
    const audioExts = ['.mp3', '.wav', '.ogg', '.m4a', '.flac','.opus'];

    const droppedAudioFiles = files.filter(file => {
      const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
      return audioExts.includes(ext);
    });

    if (droppedAudioFiles.length === 0) {
      alert('No supported audio files were dropped.');
      return;
    }

    const newPaths = droppedAudioFiles.map(f => f.path);
    audioFiles = audioFiles.concat(newPaths);
    renderPlaylist();
  });

  const clearPlaylistBtn = document.getElementById('clearPlaylistBtn');

  clearPlaylistBtn.addEventListener('click', () => {
    if (audioFiles.length === 0) return;
    audioFiles = [];
    currentIndex = 0;
    audio.pause();
    audio.src = '';
    visualizerCanvas.style.backgroundImage = 'none';
    visualizerCanvas.style.backgroundColor = '#111111';
    renderPlaylist();
    window.electronAPI.updateTrack({ songName: 'No Track', artUrl: null, isPlaying: false });
  });

  [volumeSlider, progressBar].forEach(slider => {
    updateSliderBackground(slider);
    slider.addEventListener('input', () => updateSliderBackground(slider));
  });

  filePickerBtn.addEventListener('click', async () => {
  try {
    if ('Notification' in window && Notification.permission !== 'granted') {
      await Notification.requestPermission();
    }
    const result = await window.electronAPI.pickFolder();
    if (!result || result.canceled) {
      return;
    }
    const { folderPath, audioFilePaths } = result;
    if (!audioFilePaths.length) {
      alert('No audio files found in that folder');
      return;
    }

    
      audioFiles = audioFilePaths;
    savedSortedOrder = [];
    isShuffled = false;
    shuffleBtn.classList.remove('enabled');

    currentIndex = 0;
    await applySavedSort();

    updateStoredPlaylist();
    renderPlaylist();
    playTrack(0);
    scrollToCurrentTrack();
  } catch (err) {
    console.error('Folder load error:', err);
    alert('Error: ' + err.message);
  }
});
  savePlaylistBtn.addEventListener('click', async () => {
    if (audioFiles.length === 0) {
      alert('No tracks to save!');
      return;
    }
    const playlist = audioFiles;
    const success = await window.electronAPI.savePlaylist(playlist);
    alert(success ? 'Playlist saved!' : 'Failed to save playlist');
  });

  loadPlaylistBtn.addEventListener('click', async () => {
    const { canceled, filePaths } = await window.electronAPI.openFile();
    if (canceled || !filePaths.length) return;

    const playlistPath = filePaths[0];
    const ext = playlistPath.split('.').pop().toLowerCase();

    if (ext === 'playlist') {
      const playlistData = await window.electronAPI.readFile(playlistPath);
      audioFiles = JSON.parse(playlistData);
    } else if (ext === 'm3u') {
      audioFiles = await parseM3UFile(playlistPath);
    } else {
      alert('Unsupported playlist format');
      return;
    }

    currentIndex = 0;
    renderPlaylist();
    playTrack(currentIndex);
  });

  const volumePercent = document.getElementById('volumePercent');

  volumeSlider.addEventListener('input', (e) => {
    audio.volume = e.target.value;
    volumePercent.textContent = Math.round(e.target.value * 100) + '%';
    localStorage.setItem('volumeLevel', e.target.value);
    window.electronAPI.updateVolume(e.target.value);
  });

  const savedVolume = localStorage.getItem('volumeLevel');
  if (savedVolume !== null) {
    volumeSlider.value = savedVolume;
    audio.volume = savedVolume;
    volumePercent.textContent = Math.round(savedVolume * 100) + '%';
    updateSliderBackground(volumeSlider);
  } else {
    volumeSlider.value = 1;
    audio.volume = 1;
    volumePercent.textContent = '100%';
    updateSliderBackground(volumeSlider);
  }

 let lastSelectedIndex = null;

function renderPlaylist() {
  playlistElem.innerHTML = '';
  audioFiles.forEach((item, index) => {
  const li = document.createElement('li');

  if (typeof item === 'string') {
    li.textContent = item.split(/[\\/]/).pop();
  } else if (item.isStream) {
    li.innerHTML = '';

    const icon = document.createElement('img');
    icon.src = 'build/radio.svg';
    icon.style.width = '16px';
    icon.style.height = '16px';
    icon.style.marginRight = '8px';
    icon.style.verticalAlign = 'middle';
    icon.style.filter = 'brightness(0) invert(1)';

    const text = document.createElement('span');
    text.textContent = item.name || 'Unknown Station';

    li.appendChild(icon);
    li.appendChild(text);
  } else {
    li.textContent = 'Unknown Track';
  }

  li.addEventListener('click', (e) => {
    if (contextMenuOpen) {
      contextMenu.style.display = 'none';
      contextMenuOpen = false;
      e.stopPropagation();
      return;
    }

    if (e.shiftKey && lastSelectedIndex !== null) {
      const start = Math.min(lastSelectedIndex, index);
      const end = Math.max(lastSelectedIndex, index);
      selectedIndices.clear();
      for (let i = start; i <= end; i++) selectedIndices.add(i);
    } else if (e.ctrlKey || e.metaKey) {
      if (selectedIndices.has(index)) selectedIndices.delete(index);
      else selectedIndices.add(index);
      lastSelectedIndex = index;
    } else {
      selectedIndices.clear();
      selectedIndices.add(index);
      lastSelectedIndex = index;
      currentIndex = index;
      playTrack(index);
    }

    updateSelectionVisuals();
  });

  if (selectedIndices.has(index)) {
    li.classList.add('selected');
  }
  if (index === currentIndex) {
    li.classList.add('active');
  }

  playlistElem.appendChild(li);
});
}


const selectedIndices = new Set();

function updateSelectionVisuals() {
  const items = playlistElem.querySelectorAll('li');
  items.forEach((li, i) => {
    if (selectedIndices.has(i)) {
      li.classList.add('selected');
    } else {
      li.classList.remove('selected');
    }
    
    if (i === currentIndex) {
      li.classList.add('active');
    } else {
      li.classList.remove('active');
    }
  });
}

  async function parseM3UFile(filePath) {
    const content = await window.electronAPI.readFile(filePath);
    const lines = content
      .split(/\r?\n/)
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'));

    const pathSeparator = window.navigator.platform.startsWith('Win') ? '\\' : '/';
    const baseDir = filePath.substring(0, filePath.lastIndexOf(pathSeparator));

    const audioPaths = lines.map(line => {
      if (line.startsWith('/') || /^[a-zA-Z]:\\/.test(line)) return line;
      return baseDir + (baseDir.endsWith(pathSeparator) ? '' : pathSeparator) + line;
    });

    return audioPaths;
  }

 async function getAlbumArtUrl(filePath) {
  const defaultImage = 'build/default-artwork.jpg';
  if (typeof filePath !== 'string' || !['.mp3', '.m4a', '.flac', '.opus'].some(ext => filePath.toLowerCase().endsWith(ext))) {
    return defaultImage;
  }

  try {
    const buffer = await window.electronAPI.readFileBuffer(filePath);
    const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    const blob = new Blob([arrayBuffer]);

    return new Promise((resolve) => {
      window.jsmediatags.read(blob, {
        onSuccess: function(tag) {
          const tags = tag.tags;
          if (tags.picture) {
            const picture = tags.picture;
            const uint8Array = new Uint8Array(picture.data);
            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < uint8Array.length; i += chunkSize) {
              binary += String.fromCharCode(...uint8Array.subarray(i, i + chunkSize));
            }
            const base64String = btoa(binary);
            resolve(`data:${picture.format};base64,${base64String}`);
          } else {
            resolve(defaultImage);
          }
        },
        onError: function(error) {
          console.error('jsmediatags error:', error);
          resolve(defaultImage);
        }
      });
    });
  } catch (err) {
    console.error('Failed to read file for tags:', err);
    return defaultImage;
  }
}

async function setVisualizerBackground(item) {
  if (typeof item === 'string') {
    const imageUrl = await getAlbumArtUrl(item);
    visualizerCanvas.style.backgroundImage = `url(${imageUrl})`;
    visualizerCanvas.style.backgroundColor = '#111111';
  } else {
    visualizerCanvas.style.backgroundImage = 'none';
    visualizerCanvas.style.backgroundColor = '#111111';
  }
}

  async function playTrack(index) {
  if (index < 0 || index >= audioFiles.length) return;

  currentIndex = index;
  selectedIndices.clear();
  selectedIndices.add(currentIndex);
  lastSelectedIndex = currentIndex;

  const item = audioFiles[index];

  let src;
  let displayName;

  if (typeof item === 'string') {

    let pathPart = item.replace(/\\/g, '/');
    src = 'file://' + pathPart.split('/').map(encodeURIComponent).join('/');
    displayName = item.split(/[\\/]/).pop();
  } else if (item.isStream) {
    src = item.url;
    displayName = item.name || 'Radio Stream';
  } else {
    return;
  }

 if (Hls.isSupported() && src.endsWith('.m3u8') || src.includes('.m3u8?')) {
    const hls = new Hls();
    hls.loadSource(src);
    hls.attachMedia(audio);
    hls.on(Hls.Events.MANIFEST_PARSED, () => {
      audio.play();
    });
  
    hls.on(Hls.Events.ERROR, (event, data) => {
      if (data.fatal) {
        console.error('Fatal HLS error:', data);
        audio.src = src;
        audio.play();
      }
    });
  } else {
    audio.src = src;
    audio.play();
  }
  await setVisualizerBackground(item);

  const trackData = {
    songName: displayName,
    artUrl: visualizerCanvas.style.backgroundImage.slice(5, -2) || null,
    isPlaying: true,
    volume: audio.volume
  };
  window.electronAPI.updateTrack(trackData);

  renderPlaylist();
  updateSelectionVisuals();
  visualize();
  scrollToCurrentTrack();
  if (item.isStream) {
    currentTimeElem.textContent = 'LIVE';
    durationElem.textContent = '∞';
  } else {
    currentTimeElem.textContent = '0:00';
    durationElem.textContent = '0:00';
  }

  if (notifyEnabled && Notification.permission === 'granted') {
    window.electronAPI.notify('Now Playing', displayName);
  }
}


const playPauseBtn = document.getElementById('playPauseBtn');
const playPauseIcon = document.getElementById('playPauseIcon');

playPauseBtn.addEventListener('click', () => {
  if (audio.paused) {
    audio.play();
    if (notifyEnabled && Notification.permission === 'granted') {
    window.electronAPI.notify('Resuming');
  }
  } else {
    audio.pause();
    if (notifyEnabled && Notification.permission === 'granted') {
    window.electronAPI.notify('Paused');
  }
  }
});


audio.addEventListener('play', () => {
  playPauseIcon.src = 'build/pause.svg';
  playPauseIcon.alt = 'Pause';
  window.electronAPI.updateTrack({ isPlaying: true });
});

audio.addEventListener('pause', () => {
  playPauseIcon.src = 'build/play.svg';
  playPauseIcon.alt = 'Play';
  window.electronAPI.updateTrack({ isPlaying: false });
});


if (audio.paused) {
  playPauseIcon.src = 'build/play.svg';
} else {
  playPauseIcon.src = 'build/pause.svg';
}

  volumeSlider.addEventListener('input', (e) => {
    audio.volume = e.target.value;
  });

  audio.addEventListener('play', () => {
    window.electronAPI.updateTrack({ isPlaying: true, volume: audio.volume });
  });

  audio.addEventListener('pause', () => {
    window.electronAPI.updateTrack({ isPlaying: false, volume: audio.volume });
  });
audio.addEventListener('timeupdate', () => {
  const currentItem = audioFiles[currentIndex];

  if (!isSeeking) {
    if (currentItem && currentItem.isStream) {
      currentTimeElem.textContent = 'LIVE';
      durationElem.textContent = '∞';
      progressBar.value = 0;
      progressBar.max = 1;
      window.electronAPI.updateTime(0, Infinity);
    } else if (audio.duration && isFinite(audio.duration)) {
      progressBar.max = audio.duration;
      progressBar.value = audio.currentTime;
      currentTimeElem.textContent = formatTime(audio.currentTime);
      durationElem.textContent = formatTime(audio.duration);
      window.electronAPI.updateTime(audio.currentTime, audio.duration);
    }
    updateSliderBackground(progressBar);
  }
});


  progressBar.addEventListener('input', () => {
    isSeeking = true;
  });

  progressBar.addEventListener('change', () => {
    audio.currentTime = parseFloat(progressBar.value);
    isSeeking = false;
    updateSliderBackground(progressBar);
  });

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  }


let lastWidth = 0;
let lastHeight = 0;

function visualize() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }

  const canvas = visualizerCanvas;
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  if (width !== lastWidth || height !== lastHeight) {
    canvas.width = width;
    canvas.height = height;
    lastWidth = width;
    lastHeight = height;
  }

  const ctx = canvas.getContext('2d');
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);

  let frameCounter = 0;
  let lastTime = 0;

function draw(timestamp) {
    animationFrameId = requestAnimationFrame(draw);
    if (lastTime && (timestamp - lastTime) < 33) return;
    lastTime = timestamp || performance.now();
    ctx.clearRect(0, 0, width, height);
    let songName = 'No Track';
    let isRadioStream = false;
    const currentItem = audioFiles[currentIndex];

if (currentItem) {
  if (typeof currentItem === 'string') {
    songName = currentItem.split(/[\\/]/).pop() || 'Unknown Track';
  } else if (currentItem.isStream) {
    isRadioStream = true;
    if (currentItem.name && currentItem.name.trim() !== '') {
      songName = currentItem.name.trim();
    } else {
      try {
        songName = new URL(currentItem.url).hostname;
      } catch {
        songName = 'Radio Stream';
      }
    }
  }
}

if (songName.length > 50) {
  songName = songName.slice(0, 47) + '...';
}

const isMini = document.body.classList.contains('mini-mode');
const iconSize = isMini ? 10 : 14;
const textY = isMini ? 14 : 18;
const maxWidth = width * 0.92;
ctx.font = isMini ? '10.5px Arial' : '14px Arial';
ctx.textAlign = 'center';
ctx.fillStyle = '#FFFFFF';
ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
ctx.shadowBlur = 3;
ctx.shadowOffsetX = 1;
ctx.shadowOffsetY = 1;

let displayText = songName;
let textWidth = ctx.measureText(displayText).width;

if (textWidth > maxWidth) {
  let ellipsis = '...';
  let availableWidth = maxWidth - ctx.measureText(ellipsis).width;
  let low = 0, high = songName.length;
  while (low < high) {
    let mid = Math.floor((low + high + 1) / 2);
    let testText = songName.slice(0, mid);
    if (ctx.measureText(testText).width <= availableWidth) {
      low = mid;
    } else {
      high = mid - 1;
    }
  }
  displayText = songName.slice(0, low) + ellipsis;
}


let textX = width / 2;

if (isRadioStream && radioIconImg.complete) {
const totalWidth = ctx.measureText(displayText).width + iconSize + 8;
const startX = width / 2 - totalWidth / 2;
ctx.save();
ctx.filter = 'brightness(0) invert(1)';
ctx.drawImage(radioIconImg, startX, textY - iconSize + 2, iconSize, iconSize);
ctx.restore();
 
  textX = startX + iconSize + 8 + ctx.measureText(displayText).width / 2;
} else {
  textX = width / 2;
}

ctx.fillText(displayText, textX, textY);
ctx.shadowColor = 'transparent';
ctx.shadowBlur = 0;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;


    if (!visualizerToggle || !analyser || !isMainWindowVisible) return;

    analyser.getByteFrequencyData(dataArray);
frameCounter++;
if (frameCounter % 2 === 0 && window.electronAPI?.updateVisualizer) {
  window.electronAPI.updateVisualizer(Array.from(dataArray));
}


let lowEnergy = 0;
const lowStart = 0;
const lowEnd = 10;
for (let i = lowStart; i < lowEnd; i++) {
  lowEnergy += dataArray[i];
}
lowEnergy /= (lowEnd - lowStart);

if (!window.energyHistory) window.energyHistory = [];
window.energyHistory.push(lowEnergy);
if (window.energyHistory.length > 32) window.energyHistory.shift();

const avgEnergy = window.energyHistory.reduce((a,b) => a+b) / window.energyHistory.length;

const thresholdMultiplier = 1.8;
const minThreshold = 80;

let isBeat = false;
if (lowEnergy > Math.max(avgEnergy * thresholdMultiplier, minThreshold) && !window.lastBeat) {
  isBeat = true;
  window.lastBeat = true;
} else if (lowEnergy < avgEnergy * 1.2) {
  window.lastBeat = false;
}
    frameCounter++;
    if (frameCounter % 2 === 0 && window.electronAPI?.updateVisualizer) {
      window.electronAPI.updateVisualizer(Array.from(dataArray));
    }

  if (isRainbowActive) {
  let bass = 0;
  let mids = 0;

  const BASS_BINS = 6;
  const MID_START = 12;
  const MID_BINS = 10;

  for (let i = 0; i < BASS_BINS; i++) bass += dataArray[i];
  for (let i = MID_START; i < MID_START + MID_BINS; i++) mids += dataArray[i];

  bass /= BASS_BINS;
  mids /= MID_BINS;
  if (window.prevBass === undefined) window.prevBass = bass;
  if (window.prevMids === undefined) window.prevMids = mids;

  const bassDelta = bass - window.prevBass;
  const midDelta = mids - window.prevMids;

  window.prevBass = bass;
  window.prevMids = mids;
  if (!window.bassDeltaHist) window.bassDeltaHist = [];
  window.bassDeltaHist.push(bassDelta);
  if (window.bassDeltaHist.length > 20) window.bassDeltaHist.shift();

  const avgBassDelta =
    window.bassDeltaHist.reduce((a, b) => a + b, 0) /
    window.bassDeltaHist.length;
  const now = performance.now();
  if (!window.lastBeatTime) window.lastBeatTime = 0;

  const MIN_INTERVAL = 1; 
  let triggerBeat = false;
  if (
    bassDelta > avgBassDelta * 1.8 && 
    bassDelta > 4 &&                  
    bassDelta > midDelta * 1.5 &&     
    now - window.lastBeatTime > MIN_INTERVAL
  ) {
    triggerBeat = true;
    window.lastBeatTime = now;
  }


  if (window.rainbowHue === undefined) window.rainbowHue = Math.floor(Math.random() * 360);

  if (triggerBeat) {
    window.rainbowHue = (window.rainbowHue + 60) % 360;
  }

  const color = `hsl(${window.rainbowHue}, 100%, ${triggerBeat ? 70 : 55}%)`;
  const darkColor = `hsl(${window.rainbowHue}, 100%, ${triggerBeat ? 40 : 30}%)`;

  document.documentElement.style.setProperty('--primary-color', color);
  document.documentElement.style.setProperty('--primary-dark', darkColor);
}



    const barCount = isMini ? 48 : 64;
    const step = Math.max(1, Math.floor(bufferLength / barCount));
    const barWidth = Math.max(1.5, (width / barCount) * 0.8);
    const centerX = width / 2;
    const spacing = 1;

    const currentPrimaryColor = getComputedStyle(document.documentElement)
      .getPropertyValue('--primary-color').trim() || '#a88cff';

    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, currentPrimaryColor);
    gradient.addColorStop(0.5, adjustColor(currentPrimaryColor, -20));
    gradient.addColorStop(1, currentPrimaryColor);
    ctx.fillStyle = gradient;

    for (let i = 0; i < barCount; i++) {
      const value = dataArray[i * step] || 0;
      const barHeight = value * (height / 255) * (isMini ? 0.7 : 0.55);
      const xLeft = centerX - (i + 1) * (barWidth + spacing);
      const xRight = centerX + i * (barWidth + spacing);
      const y = height - barHeight;

      if (xLeft + barWidth > 0) ctx.fillRect(xLeft, y, barWidth, barHeight);
      if (xRight < width) ctx.fillRect(xRight, y, barWidth, barHeight);
    }
  }

  animationFrameId = requestAnimationFrame(draw);
}



let isMainWindowVisible = true;

document.addEventListener('visibilitychange', () => {
  isMainWindowVisible = !document.hidden;
  if (!isMainWindowVisible) {
    stopVisualizer();
  } else {
    if (visualizerToggle) visualize();
  }
});
  function adjustColor(color, percent) {
    if (color.startsWith('hsl')) {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (!match) return color;
      let [, hue, saturation, lightness] = match;
      hue = parseInt(hue);
      saturation = parseInt(saturation);
      lightness = parseInt(lightness);
      lightness = Math.min(100, Math.max(0, lightness + percent));
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    let hex = color.replace('#', '');
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    if (!/^[0-9a-fA-F]{6}$/.test(hex)) return color;

    let r = parseInt(hex.slice(0, 2), 16);
    let g = parseInt(hex.slice(2, 4), 16);
    let b = parseInt(hex.slice(4, 6), 16);

    r = Math.min(255, Math.max(0, Math.round(r * (1 + percent / 100))));
    g = Math.min(255, Math.max(0, Math.round(g * (1 + percent / 100))));
    b = Math.min(255, Math.max(0, Math.round(b * (1 + percent / 100))));

    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }

  const notifyToggleBtn = document.getElementById('notifyToggleBtn');
  const bellIcon = document.getElementById('bellIcon');
  bellIcon.src = notifyEnabled ? 'build/bell-ring.svg' : 'build/bell.svg';

  notifyToggleBtn.addEventListener('click', () => {
    notifyEnabled = !notifyEnabled;
    localStorage.setItem('notifyEnabled', notifyEnabled);
    bellIcon.src = notifyEnabled ? 'build/bell-ring.svg' : 'build/bell.svg';
    if (notifyEnabled && 'Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission().then(permission => {
        if (permission !== 'granted') {
          notifyEnabled = false;
          localStorage.setItem('notifyEnabled', 'false');
          alert('Notifications not enabled in browser.');
        }
      });
    }
  });

  const visualizerToggleBtn = document.getElementById('visualizerToggleBtn');
  const visualizerIcon = document.getElementById('visualizerIcon');
  visualizerIcon.src = visualizerToggle ? 'build/visualizer.svg' : 'build/visualizeroff.svg';

  visualizerToggleBtn.addEventListener('click', () => {
  visualizerToggle = !visualizerToggle;
  localStorage.setItem('visualizerToggle', visualizerToggle);
  visualizerIcon.src = visualizerToggle ? 'build/visualizer.svg' : 'build/visualizeroff.svg';

  if (visualizerToggle) {
    if (!audio.paused) visualize();
    audio.addEventListener('play', visualize);
  } else {
    audio.removeEventListener('play', visualize);
    if (!animationFrameId && !audio.paused) visualize();
  }
});

  if (visualizerToggle) {
    audio.addEventListener('play', visualize);
  }

audio.addEventListener('ended', () => {
  if (repeatTrack) {
    playTrack(currentIndex);
  } else {
    currentIndex++;
    if (currentIndex >= audioFiles.length) {
      currentIndex = 0;
    }
    playTrack(currentIndex);
  }
});

  async function applySavedSort() {
    const criteria = localStorage.getItem('sortCriteria');
    const order = localStorage.getItem('sortOrder');

    if (criteria && order) {
      const sortIdMap = {
        'name-asc': 'sortNameAsc',
        'name-desc': 'sortNameDesc',
        'date-asc': 'sortDateAsc',
        'date-desc': 'sortDateDesc'
      };

      const key = `${criteria}-${order}`;
      const buttonId = sortIdMap[key];

      if (buttonId) {
        updateSortCheckmark(buttonId);
      }

      return await sortPlaylist(criteria, order === 'asc');
    }
    return 0;
  }

  function updateStoredPlaylist() {
    try {
      localStorage.setItem('sortedPlaylist', JSON.stringify(audioFiles));
    } catch (e) {
      console.error('Failed to save playlist:', e);
    }
  }

function scrollToCurrentTrack() {
  const items = playlistElem.querySelectorAll('li');
  const currentItem = items[currentIndex];
  if (currentItem) {
    currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

  let rainbowHue = 0;
function stopVisualizer() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  ctx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
  window.electronAPI.disableVisualizer();
}





function startRainbowColorLoop() {
  if (!isRainbowActive || rainbowIntervalId) return;

  rainbowIntervalId = setInterval(() => {
    rainbowHue = (rainbowHue + 5) % 360;
    const color = `hsl(${rainbowHue}, 100%, 65%)`;
    const darkColor = `hsl(${rainbowHue}, 100%, 45%)`;

    document.documentElement.style.setProperty('--primary-color', color);
    document.documentElement.style.setProperty('--primary-dark', darkColor);

    updateSliderBackground(volumeSlider);
    updateSliderBackground(progressBar);
  }, 100);
}

function stopRainbowLoop() {
  if (rainbowIntervalId) {
    clearInterval(rainbowIntervalId);
    rainbowIntervalId = null;
  }
}

  window.electronAPI.onUpdateTrack((data) => {
    if (data.isPlaying !== undefined) {
      if (data.isPlaying && audio.paused) {
        audio.play();
      } else if (!data.isPlaying && !audio.paused) {
        audio.pause();
      }
    }
  });

  window.electronAPI.onUpdateVolume((volume) => {
    audio.volume = volume;
    volumeSlider.value = volume;
    volumePercent.textContent = Math.round(volume * 100) + '%';
    localStorage.setItem('volumeLevel', volume);
    updateSliderBackground(volumeSlider);
  });

  window.electronAPI.onRequestCurrentState(() => {
  if (audioFiles[currentIndex]) {
    const filePath = audioFiles[currentIndex];
    setVisualizerBackground(filePath).then(() => {
      const trackData = {
        songName: filePath.split(/[\\/]/).pop(),
        artUrl: visualizerCanvas.style.backgroundImage.slice(5, -2),
        isPlaying: !audio.paused,
        filePath: filePath,
        volume: audio.volume
      };
      window.electronAPI.updateTrack(trackData);
      window.electronAPI.updateTheme({ color: themeColor, isRainbow: isRainbowActive });
    });
  } else {
  
    window.electronAPI.updateTrack({ songName: 'No Track', artUrl: null, isPlaying: false });
    window.electronAPI.updateTheme({ color: themeColor, isRainbow: isRainbowActive });
  }
});

  window.electronAPI.onPlayPrevious(() => {
    if (currentIndex > 0) {
      currentIndex--;
      playTrack(currentIndex);
    }
  });

  window.electronAPI.onSeekFromMini((time) => {
  if (!isNaN(time) && audio.duration) {
    audio.currentTime = time;    
    progressBar.value = time;    
    currentTimeElem.textContent = formatTime(time);
    updateSliderBackground(progressBar);
  }
})

  window.electronAPI.onPlayNext(() => {
    if (currentIndex < audioFiles.length - 1) {
      currentIndex++;
      playTrack(currentIndex);
    } else if (repeatTrack) {
      currentIndex = 0;
      playTrack(currentIndex);
    }
  });

  window.electronAPI.onTogglePlay(() => {
    if (audio.paused) {
      audio.play();
    } else {
      audio.pause();
    }
  });
</script>

<div id="streamModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; z-index: 9999;">
  <div style="background: #222; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px; color: white;">
    <h3 style="margin-top: 0; color: var(--primary-color);">Add Radio Stream</h3>
    <label>Stream URL (.mp3, .aac, .pls, .m3u etc.):</label>
    <input type="text" id="streamUrlInput" style="width: 100%; padding: 10px; margin: 10px 0; background: #333; border: none; border-radius: 5px; color: white;" placeholder="https://example.com/stream.mp3" />
    
    <label>Station Name (optional):</label>
    <input type="text" id="streamNameInput" style="width: 100%; padding: 10px; margin: 10px 0; background: #333; border: none; border-radius: 5px; color: white;" placeholder="My Favorite Station" />
    
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
      <button id="cancelStreamBtn" style="background: #444; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Cancel</button>
      <button id="addStreamConfirmBtn" style="background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Add</button>
    </div>
  </div>
</div>
</body>
</html>